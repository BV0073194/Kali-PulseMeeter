#!/usr/bin/env bash

init (){
	local device_type=$1
	local device=$2
	local channels="$3"

	# pulse
	if [ $is_pulse = true ]; then
		case $device_type in
			"sink")
				pactl list sinks short >/dev/null 2>&1 | grep $device && exit
				pactl load-module module-null-sink \
					sink_name=$device \
					sink_properties="device.description="$device"" >/dev/null 2>&1 || 
						printf "Error creating virtual input $device\n" >&2
			;;

			"source")
				pactl list sources short >/dev/null 2>&1 | grep $device && exit
				pactl load-module module-null-sink sink_name=$device"device" >/dev/null 2>&1 ||
					printf "Error creating virtual output sink $device\n" >&2

				pactl load-module module-remap-source source_name=$device master=$device"_sink.monitor" source_properties=device.description=$device 2>/dev/null || 
				printf "Error creating virtual output $device\n" >&2
			;;
		esac

	# pipewire
	else

		case "$device_type" in
			"sink") class="Sink" ;;
			"source") class="Source/Virtual" ;;
			*) exit
		esac

		# check if device exists
		pw-cli info $device 2>&1 | grep Error >/dev/null || exit

		# create device
		pw-cli create-node adapter "{
			factory.name=support.null-audio-sink
			node.name=$device
			node.description=$device
			media.class=Audio/$class
			audio.channels=$channels
			monitor.channel-volumes = true
			object.linger=true
		}" >/dev/null || printf "Error creating $device_type $device\n" >&2

		#audio.position=[ $channel_map ]
	fi
}

remove (){
	local device=$1

	# pulse
	if [ $is_pulse = true ]; then
		index="$(LC_ALL=C pactl list modules | grep -B 2 "$device " | grep Module | sed 's/.*#//g')"
		[ -z "$index" ] || pactl unload-module $index 
		
		aux_index="$(LC_ALL=C pactl list modules | grep -B 2 $device'_sink' | grep Module | sed 's/.*#//g')"
		[ -z "$aux_index" ] || pactl unload-module $aux_index

	# pipewire
	else
		pw-cli destroy $device 2>/dev/null 1>&2
	fi
}

connect (){
	local input=$1
	local output=$2
	local latency=${3:-200}

	[ -z "$input" -o -z "$output" ] && exit

	# pulse
	if [ $is_pulse = true ]; then
		index="$(LC_ALL=C pactl list modules 2>/dev/null | grep -B 2 "$output source=$input" | grep Module | sed 's/.*#//g')"
		[ -z "$index" ] || pactl unload-module $index 2>/dev/null ||
			printf "Error disconnecting $input $2 to System:$3\n" >&2

		LC_ALL=C pactl list modules 2>/dev/null | grep -B 2 "$output source=$input" >/dev/null || \
		pactl load-module module-loopback sink=$output source=$input sink_dont_move=true source_dont_move=true latency_msec=$latency 2>/dev/null ||
			printf "Error connecting $input to $output\n" >&2

	# pipewire
	else
		local port_map="$3"
		local input_ports=$(get_ports output $input)
		local output_ports=$(get_ports input $output)

		if [ -z "$port_map" -o "$3" = 'None' ]; then
			pw-link $input $output 2> /dev/null
		else
			for i in $(echo "$port_map"); do
				input_port_index=$(( $(printf "%s" "$i" | cut -d ":" -f1) + 1 ))
				output_port_index=$(( $(printf "%s" "$i" | cut -d ":" -f2) + 1 ))

				input_port=$(printf "%s" "$input_ports" | head -$input_port_index | tail -1)
				output_port=$(printf "%s" "$output_ports" | head -$output_port_index | tail -1)

				pw-link $input:$input_port $output:$output_port 2> /dev/null
			done
		fi
	fi
}

disconnect (){
	local input=$1
	local output=$2

	[ -z "$input" -o -z "$output" ] && exit

	# pulse
	if [ $is_pulse = true ]; then
		index="$(LC_ALL=C pactl list modules 2>/dev/null | grep -B 2 "$output source=$input" | grep Module | sed 's/.*#//g')"
		[ -z "$index" ] || pactl unload-module $index 2>/dev/null ||
			printf "Error disconnecting $input $2 to System:$3\n" >&2
	
	# pipewire
	else
		local port_map="$3"
		local input_ports=$(get_ports output $input)
		local output_ports=$(get_ports input $output)

		if [ -z "$port_map" -o "$3" = 'None' ]; then
			pw-link $input $output 2> /dev/null
		else
			for i in $(echo "$port_map"); do
				input_port_index=$(( $(printf "%s" "$i" | cut -d ":" -f1) + 1 ))
				output_port_index=$(( $(printf "%s" "$i" | cut -d ":" -f2) + 1 ))

				input_port=$(printf "%s" "$input_ports" | head -$input_port_index | tail -1)
				output_port=$(printf "%s" "$output_ports" | head -$output_port_index | tail -1)

				pw-link -d $input:$input_port $output:$output_port 2> /dev/null
			done
		fi
	fi
}

set_primary () {
	local device=$1
	local name=$2
	pactl set-default-$device $name >/dev/null 2>&1 || 
		echo "Error setting $device $name as primary" >&2
}

mute (){
	local device_type=$1
	local device=$2
	local status=$3

	pactl set-$device_type-mute $device $status
}

rename () {
	pacmd update-sink-proplist $1 device.description=$2
}


get_source_by_id() {
	id=$1
	LC_ALL=C pactl list sources | grep "Source #$id$" -A 3 | grep 'Name: ' | sed 's/.*: //g'
}

move_sink_input_master (){
	local sink_name=$1
	local master=$2
	index=$(LC_ALL=C pactl list modules | grep -B 2 "$sink_name m" | grep Module | sed 's/.*#//g')
	[ -z "$index" ] && exit
	id=$(LC_ALL=C pactl list sink-inputs | grep -B 2 $index | grep '#' | sed 's/.*#//g')
	[ -z "$id" ] && exit
	pactl move-sink-input $id $master
}

move_sink_input (){
	app=$1
	master=$2
	pactl move-sink-input $app $master
}

move_source_output () {
	app=$1
	master=$2
	pactl move-source-output $app $master
}

get_pactl_version () {
	version=$(pactl --version | grep pactl | sed 's/.* //; s/\..*//')
	printf "%d" "$version"
}

list (){

	local device_type=$1

	if [ "$(pactl --version | grep pactl | sed 's/.* //; s/\..*//')" -lt 16 ]; then
		case $device_type in

			"sinks")
				list_cards sinks
			;;

			"sources")
				list_cards sources
			;;

			"source-outputs")
				list_source_outputs
			;;

			"sink-inputs")
				list_sink_inputs
			;;

			"virtual-sinks")
				list_virtual_sinks
			;;

			"virtual-sources")
				list_virtual_sources
			;;
	esac

	# pulse 16.0 or later
	else
		pactl -f json list $device_type 2>/dev/null
	fi
}

get_port_name() {
	type=$1
	device=$2
	for i in 'capture' 'monitor' 'playback' 'input'; do
		pw-link --$type | grep "$device:$i" >/dev/null && port_name=$i
	done
	printf "%s" "$port_name"
}

get_ports() {
	type=$1
	device=$2
	ports=$(pw-link --$type | grep "$device" | cut -d ':' -f2)
	printf "%s" "$ports"
}

# for version < 16.0
list_cards (){

	list=$(LC_ALL=C pactl list $1 | \
		awk '/Sink #/{print $2} /Source #/{print $2} /Name:/ {print $0} 
			/Description/ {print $0} /ladspa/{print $0} /remap-source/ {print $0}
			/module-null-sink/ {print $0} /module-jack-sink/ {print $0} /module-jack-source/ {print $0} /Volume/ {print $0} /null-audio-sink/ {print $0}' |\
			sed '/Base Volume/d; s/%.*//g; s/:.*\/ /: /g; /Volume/s/$/%/; s/: /:"/g; /#/!s/$/"/g;')

	# turn into json
	list=$(echo "$list" | sed ':a $!N;s/\n/, /;ta P;D;' |\
		sed ':a $!N;s/#/\n{"index":/;ta P;D;' |\
		sed '/^$/d; s/ 	/ /g; s/Description/"alsa.card_name"/g; s/Volume:"/"volume":/g; s/%"//g; s/Name/"name"/g; s/$/}/; s/, }/}/' |\
		grep -vwE Monitor | grep -vwE null | grep -vwE jack | grep -vwE remap-source | grep -vwE module-remap-source | grep -vwE ladspa)

	printf "%s" "$list" | sed '1 s/^/[/g' | sed 's/$/,/g' | sed '$ s/.$/]/g' |tr -d '\n'
}

list_virtual_sinks (){
	list=$(LC_ALL=C pactl list sinks | 
		awk '/Sink #/{print $2} /Source #/{print $2} /Name:/ {print $0} 
			/Description/ {print $0} /ladspa/{print $0} /remap-source/ {print $0}
			/module-null-sink/ {print $0} /Volume/ {print $0} /null-audio-sink/ {print $0}' |
			sed '/Base Volume/d; s/%.*//g; s/:.*\/ /: /g; /Volume/s/$/%/; s/: /:"/g; /#/!s/$/"/g;')

	# turn into json
	list=$(echo "$list" | sed ':a $!N;s/\n/, /;ta P;D;' |
		sed ':a $!N;s/#/\n{"id":/;ta P;D;' |
		sed '/^$/d; s/ 	/ /g; s/Description/"description"/g; 
			s/Volume:"/"volume":/g; s/%"//g; s/Name/"name"/g;
			s/$/}/; s/, }/}/' |
		sed '/null/!d; s/, \tfactory.*"//g' |
		grep -vwE Monitor | grep -vwE remap-source | grep -vwE module-remap-source |
		grep -vwE ladspa | grep -vwE .*_sink | grep -vwE .*rnnoise | sed 's/, Driver:.*\.c"//g')

	printf "%s" "$list" | sed '1 s/^/[/g' | sed 's/$/,/g' | sed '$ s/.$/]/g' |tr -d '\n'
}

list_virtual_sources (){
	list=$(LC_ALL=C pactl list sources | 
		awk '/Source #/{print $2} /Name:/ {print $0} 
			/Description/ {print $0} /remap-source/ {print $0}
			/Volume/ {print $0}' |
			sed '/Base Volume/d; s/%.*//g; s/:.*\/ /: /g; /Volume/s/$/%/; s/: /:"/g; /#/!s/$/"/g;')

	# turn into json
	list=$(echo "$list" | sed ':a $!N;s/\n/, /;ta P;D;' |
		sed ':a $!N;s/#/\n{"id":/;ta P;D;' |
		sed '/^$/d; s/ 	/ /g; s/Description/"description"/g; 
			s/Volume:"/"volume":/g; s/%"//g; s/Name/"name"/g;
			s/$/}/; s/, }/}/' |
		grep -vwE Monitor | grep -wE remap | sed 's/, \t.*node.group.*"//g; s/, Driver:.*\.c"//g')

	#printf "%s" "$list"
	printf "%s" "$list" | sed '1 s/^/[/g' | sed 's/$/,/g' | sed '$ s/.$/]/g' |tr -d '\n'
}

list_source_outputs (){
	apps=$(LC_ALL=C pactl list source-outputs | awk '/Source Output #/{print $3} /Source: /{print $1 $2} /icon.name =/{print $0} /binary/{print $0} /application.name = /{print $0}')

	# turn source number into name
	sources=$(echo "$apps" | grep Source:)
	for source in $sources; do
		name=$(LC_ALL=C pactl list sources | grep -A 2 "#$(echo $source | sed "s/Source://g")$" | awk '/Name/ {print $2}')
		apps=$(echo "$apps" | sed "s/$source$/device:\"$name\"/")
	done


	# sed hell to transform into json
	apps=$(echo "$apps" | sed ':a $!N;s/\n/, /;ta P;D;' |\
		sed ':a $!N;s/#/\n{"id":/;ta P;D;' |\
		sed '/^$/d; s/application\.name = /name:/g; s/application.icon_name = /"icon":/g; s/window.icon_name[^,]*,//g; s/media.icon_name = /"icon":/g; s/application.process.binary = /"binary":/g; s/$/}/; s/, }/}/' |\
		grep -vwE pavucontrol | grep -vwE pulse-vumeter | grep name | \
		sed 's/ 		/ /g; s/device/"device"/g; s/name/"name"/g')
	printf "%s" "$apps" | sed '1 s/^/[/g' | sed 's/$/,/g' | sed '$ s/.$/]/g' |tr -d '\n'
}

list_sink_inputs (){
	apps=$(LC_ALL=C pactl list sink-inputs | awk '/Sink Input #/{print $3} /Sink: /{print $1$2} /icon_name/{print $0} /application.name = /{print $0}')

	# turn sink number into name
	sinks=$(echo "$apps" | grep Sink:)
	for sink in $sinks; do
		name=$(LC_ALL=C pactl list sinks | grep -A 2 "\#$(echo $sink | sed "s/Sink://g")$" | awk '/Name/ {print $2}')
		apps=$(echo "$apps" | sed "s/$sink$/\"device\":\"$name\"/")
	done

	# sed hell to transform into json
	apps=$(echo "$apps" | sed ':a $!N;s/\n/, /;ta P;D;' |\
		sed ':a $!N;s/#/\n{"id":/;ta P;D;' |\
		sed '/^$/d;/^$/d; s/application.icon_name = /"icon":/g; s/window.icon_name[^,]*,//g; s/media.icon_name = /"icon":/g; s/application.name = /"name":/g' |\
		grep name |\
		sed 's/ 		/ /g' | sed 's/, $//; s/$/}/')
	printf "%s" "$apps" | sed '1 s/^/[/g' | sed 's/$/,/g' | sed '$ s/.$/]/g' |tr -d '\n'
}

eq (){
	status=$1
	sink_name=$2
	master=$3
	control=$4
	map=$5
	label=mbeq
	plugin=mbeq_1197

	for lib in '64' ''; do
		for i in "/usr/lib$lib/ladspa" "/usr/local/lib$lib/ladspa"; do
			[ -f "$i/$plugin.so" ] && found=1
		done
	done

	[ -z "$found" ] && exit

	ladspa $status sink $master $sink_name $label $plugin $control $map

	#info="$(LC_ALL=C pactl list modules 2>/dev/null | grep -B 2 "$sink_name m")"
	#if [ "$status" = "remove" ]; then
		#index=$(echo "$info" | grep Module | sed 's/.*#//g')
		#[ -z "$index" ] || pactl unload-module $index >/dev/null 2>&1  ||
				#echo "Error unloading eq module in $sink_name"
		#exit
	#fi

	## update module if control is different
	#if ! [ -z "$info" ]; then
		#index=$(echo "$info" | grep Module | sed 's/.*#//g')
		#if ! [ -z "$index" ]; then
			#old_control=$(echo "$info" | grep control | sed 's/.*control=//g')
			#[ "$control" = "$old_control" ] && [ "$master" != 'remove' ] && exit
			#remove $sink_name
			##pactl unload-module $index  >/dev/null 2>&1 ||
				##echo "Error unloading eq module in $sink_name"
		#fi
	#fi

	#remove $sink_name

	#pactl load-module module-ladspa-sink \
		#sink_name=$sink_name	\
		#master=$master			\
		#plugin=mbeq_1197		\
		#label=mbeq				\
		#control=$control 2>/dev/null || 
			#printf "%s" "Error loading eq in $sink_name, control: $control\n" >&2

		#sink_properties=device.description=$sink_name 
}

rnnoise() {
	sink_name=$1
	master=$2
	control=$3
	status=$4
	lat_or_map=$5


	label=noise_suppressor_mono
	plugin=librnnoise_ladspa
 
	for lib in '64' ''; do
		for i in "/usr/lib$lib/ladspa" "/usr/local/lib$lib/ladspa"; do
			if [ -f "$i/rnnoise_ladspa.so" ]; then
				label=noisetorch
				plugin=rnnoise_ladspa
				break
			elif [ -f "$i/$plugin.so" ]; then
				found=1
				break
			fi
		done
	done
	
	[ -z "$found" ] && exit 1

	ladspa $status source $master $sink_name $label $plugin $control $lat_or_map
}

#compressor (){
		##plugin=sc4m_1916		\
		##label=sc4m				\
#}

ladspa() {

	local status=$1
	local device_type=$2
	local master=$3
	local sink_name=$4
	local label=$5
	local plugin=$6
	local control=$7

	# latency for pulse, channel map for pipewire
	local latency=$8
	local map=$8

	pactl list "$device_type"s short 2>&1 | grep $master >/dev/null || exit

	# check if plugin existis in file system
	for lib in '64' ''; do
		for i in "/usr/lib$lib/ladspa" "/usr/local/lib$lib/ladspa"; do
			if [ -f "$i/$plugin.so" ]; then
				found=1
				break
			fi
		done
	done

	[ -z "$found" ] && exit 1

	## remove old sinks
	# sources need one extra sink, so we need to remove it
	remove $sink_name"_in"
	remove $sink_name

	## create devices
	if [ "$status" = "connect" ]; then

		# sources need an extra sink to work
		if [ "$device_type" = "source" ]; then
			init sink $sink_name $map
			input=$master
			master=$sink_name
			sink_name+='_in'
			channels="channels=$map"

		elif [ $is_pulse = false ]; then

			# pipewire wont allow ladspa sinks to connect directly to virtual sources, 
			# so we need to add a middleground sink
			if ! pactl list sinks short | grep $master; then
				init sink $sink_name $map
				connect $sink_name $master
				master=$sink_name
				sink_name+='_in'
				channels="channels=$map"
			fi
		fi

		#echo $channels
		# create ladspa sink
		pactl load-module module-ladspa-sink \
			master=$master \
			sink_name=$sink_name \
			label=$label \
			plugin=$plugin \
			control=$control $channels ||
				echo "Error loading $label ladspa sink $sink_name for $master"


		[ $is_pulse = false ] && latency=''
		# we need to connect our source to the filter
		[ "$device_type" = "source" ] && connect $input $sink_name $latency
	fi
}

get_sink_input_chann_num (){
	output=$(LC_ALL=C pactl list sink-inputs | grep -e 'Sink Input #' -e 'Volume' | sed 's/.*#//g' | grep $1$ -A 1 | grep Volume)
	printf "%s" "${output//[^%]}" | wc -m
}

get_source_output_chann_num (){
	output=$(LC_ALL=C pactl list source-outputs | grep -e 'Source Output #' -e 'Volume' | sed 's/.*#//g' | grep $1$ -A 1 | grep Volume)
	printf "%s" "${output//[^%]}" | wc -m
}

get_sink_input_volume(){
	output=$(LC_ALL=C pactl list sink-inputs | grep -e 'Sink Input #' -e 'Volume' | sed 's/.*#//g' | grep $1$ -A 1 | grep Volume | sed -e 's,.* \([0-9][0-9]*\)%.*,\1,')
	printf "%d" $output 
}

get_source_output_volume(){
	output=$(LC_ALL=C pactl list source-outputs | grep -e 'Source Output #' -e 'Volume' | sed 's/.*#//g' | grep $1$ -A 1 | grep Volume | sed -e 's,.* \([0-9][0-9]*\)%.*,\1,')
	printf "%d" $output 
}

if ! pactl info >/dev/null 2>&1; then
	echo "ERROR PULSEAUDIO NOT RUNNING" >&2 
	exit 1
fi


which pulseaudio 2>/dev/null 1>&2 && is_pulse=true || is_pulse=false

case $1 in
	"init")
		init $2 $3 "$4"
	;;

	"set-primary")
		set_primary $2 $3
	;;

	"connect") 
		connect $2 $3 "$4"
	;;

	"disconnect")
		disconnect $2 $3 "$4"
	;;

	"remove")
		remove $2 $3
	;;

	"volume")
		volume $2 $3 $4
	;;

	"list")
		list $2
	;;

	"rename")
		rename $2 $3
	;;

	"mute")
		mute $2 $3 $4
	;;

	"move_sink_input_master")
		move_sink_input_master $2 $3
	;;

	"get-source-by-id")
		get_source_by_id $2
	;;

	"eq")
		eq $2 $3 $4 $5 $6
	;;

	"compressor")
		compressor $2 $3 $4
	;;

	"rnnoise")
		rnnoise $2 $3 $4 $5 $6
	;;

	"ladspa")
		ladspa $2 $3 $4 $5 $6 $7 $8 $9
	;;

	"list-virtual-sinks")
		list_virtual_sinks
	;;

	"list-virtual-sources")
		list_virtual_sources
	;;

	"list-sink-inputs")
		list_sink_inputs
	;;

	"list-source-outputs")
		list_source_outputs
	;;

	"move-sink-input")
		move_sink_input $2 $3
	;;

	"move-source-output")
		move_source_output $2 $3
	;;

	"get-sink-input-chann")
		get_sink_input_chann_num $2
	;;

	"get-source-output-chann")
		get_source_output_chann_num $2
	;;

	"get-sink-input-volume")
		get_sink_input_volume $2
	;;

	"get-source-output-volume")
		get_source_output_volume $2
	;;
	"get-port-name")
		get_port_name $2 $3
	;;

	"get-ports")
		get_ports $2 $3
	;;

	"get-pactl-version")
		get_pactl_version
	;;

	"*") echo "command not found";;
esac

